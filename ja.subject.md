
# Chapter I Introduction
ハイパーテキスト転送プロトコル（HTTP）は、分散型、協調型、ハイパーメディア情報システムのためのアプリケーションプロトコルである。
HTTPはWorld Wide Webのデータ通信の基盤であり、ハイパーテキスト文書には、ユーザーが簡単にアクセスできる他のリソースへのハイパーリンクが含まれています。
例えば、マウスのクリックやウェブブラウザの画面をタップすることでアクセスできる。
HTTPは、ハイパーテキストとワールドワイドウェブを促進するために開発されました。
Webサーバーの主な機能は、Webページを保存、処理し、クライアントに配信することです。クライアントとサーバーの間の通信は、HTTP（Hypertext Transfer Protocol）を使って行われる。
配信されるページはHTML文書であることが多く、テキストコンテンツに加えて画像、スタイルシート、スクリプトを含む場合もあります。
トラフィックの多いウェブサイトでは、複数のウェブサーバーが使用されることがあります。ユーザーエージェント（一般にウェブブラウザーやウェブクローラー）は、HTTPを使って特定のリソースを要求することで通信を開始し、サーバーはそのリソースのコンテンツ、またはそれができない場合はエラーメッセージで応答します。リソースは通常、サーバーの二次記憶装置上にある実際のファイルですが、必ずしもそうではなく、ウェブサーバーの実装方法によって異なります。
主な機能はコンテンツを提供することですが、HTTPの完全な実装には、クライアントからコンテンツを受け取る方法も含まれています。この機能は、ファイルのアップロードを含むWebフォームの送信に使用されます。

# Chapter II General rules
- プログラムはいかなる状況でもクラッシュしてはいけません（たとえメモリ不足になったとしても）、また不意に終了してはいけません。もしそうなった場合、あなたのプロジェクトは機能しないものとみなされ、成績は0点となります。
- あなたのソースファイルをコンパイルする Makefile を提出しなければなりません。Makefile は再リンクしてはいけません。
- Makefile には少なくとも $(NAME), all, clean, fclean, re のルールが含まれていなければなりません。
- c++とフラグ-Wall -Wextra -Werrorでコードをコンパイルしてください。
- あなたのコードはC++ 98標準に準拠していなければなりません。それから、フラグ -std=c++98を追加してもコンパイルできるはずです。
- 常にできる限り多くの C++ の機能を使って開発するようにしてください (たとえば <string.h> よりも <cstring> を選んでください)。Cの関数を使うこともできますが、可能であれば常にC++版を使うように してください。
- 外部ライブラリやBoostライブラリの使用は禁止する。

# Chapter III Mandatory part
Program name :webserv
Turn in files :Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp,
configuration files :Makefile NAME, all, clean, fclean, re
Arguments :[A configuration file]
External functs. :Everything in C++ 98. execve, dup, dup2, pipe, strerror, gai_strerror, errno, dup, dup2, fork, htons, htonl, ntohs, ntohl, select, poll, epoll (epoll_create, epoll_ctl, epoll_wait), kqueue (kqueue, kevent), socket, accept, listen, send, recv, bind, connect, getaddrinfo, freeaddrinfo, setsockopt, getsockname, getprotobyname, fcntl 
Libft :authorized n/a
解説 C++98でHTTPサーバを作成する
C++ 98 で HTTP サーバを作成する必要があります。
あなたの実行ファイルは、次のように実行されます。
./webserv [設定ファイル].

題名や評価基準に poll() とありますが、select(), kqueue(), epoll() などの同等のものが使用可能です。

このプロジェクトを始める前に、RFCを読み、telnetとNGINXでテストしてください。
RFCの全てを実装する必要がない場合でも、読むことで必要な機能を開発することができるようになります。

## III.1 Requirements
- プログラムは設定ファイルを引数として受け取るか、デフォルトのパスを使用しなければなりません。
- 他のウェブサーバーを内部で呼び出すことはできません。
- サーバーは決してブロックしてはならず、必要であればクライアントを適切にバウンスすることができます。
- クライアントとサーバー間のすべてのI/O操作に1つのpoll()（または同等のもの）だけを使用し、ノンブロッキングでなければなりません（リッスンを含む）。
- poll()（または同等のもの）は、readとwriteを同時にチェックしなければならない。
- poll()（または同等のもの）を通さずに読み出しや書き込みの操作を行うことは絶対に避けてください。
- readやwriteの後にerrnoの値を確認することは厳禁です。
- 設定ファイルを読み込む前に poll() (または同等) を使用する必要はありません。

ノンブロッキングのファイル記述子を使用しなければならないので、poll() (または同等)を使用せずに read/recv または write/send 関数を使用することは可能で、サーバーはブロッキングされません。
しかし、より多くのシステム・リソースを消費することになります。
したがって、poll() (または同等のもの)を使用せずに、任意のファイル記述子で read/recv または write/send を試みると、成績は 0 になります。

- FD_SET, FD_CLR, FD_ISSET, FD_ZERO のようなあらゆるマクロや定義を使うことができます (何がどのように行われているかを理解することは非常に有用です)。
- サーバーへのリクエストは必ず切断されてはいけません。
- サーバーは、あなたが選んだウェブブラウザと互換性がなければなりません。
- NGINXはHTTP 1.1に準拠しており、ヘッダーと回答の動作を比較するために使用することができると考えます。
- HTTPレスポンスのステータスコードが正確であること。
- あなたのサーバーは、何も提供されていない場合、デフォルトのエラーページを持っている必要があります。
- CGI以外のもの(PHPやPythonなど)にforkを使用することはできません。
- 完全に静的なウェブサイトを提供することができなければなりません。
- クライアントがファイルをアップロードできる必要があります。
- 少なくとも GET, POST, DELETE のメソッドが必要です。
- サーバーをストレステストしてください。サーバーは常に利用可能でなければなりません。
- あなたのサーバーは、複数のポートをリッスンできる必要があります（設定ファイルを参照してください）。

## III.2 For MacOS only
MacOSは他のUnix系OSと同じようにwrite()を実装していないので、fcntl()を使用することが許されています。
他のUnix系OSと同様の動作をさせるためには、ノンブロッキングモードでファイルディスクリプタを使用する必要があります。
ただし、fcntl()は以下のようにしか使用できません。
fcntl(fd, F_SETFL, O_NONBLOCK);
それ以外のフラグは禁止されています。

## III.3 Configuration file
NGINXの設定ファイルの'server'の部分から、いくつかのヒントを得ることができます。
設定ファイルの中で、あなたは以下のことができるはずです。
- 各'server'のポートおよびホストを選択する。
- server_namesを設定するかどうか。
- ホスト:ポートの最初のサーバーは、このホスト:ポートのデフォルトになります (つまり、他のサーバーに属さないすべてのリクエストに答えるということです)。
- デフォルトのエラーページを設定します。
- クライアントボディのサイズを制限する。
- 以下のルール/コンフィギュレーションによるルートの設定（ルートは正規表現を使用しません）。
  - ルートのために受け入れられるHTTPメソッドのリストを定義する。
  - HTTPリダイレクトを定義する。
  - ファイルが検索されるべきディレクトリまたはファイルを定義する（例えば、url /kapouetが/tmp/wwwにルートされている場合、url /kapouet/pouic/toto/pouetは/tmp/www/pouic/toto/pouetになります）。
  - ディレクトリリストのオン/オフを設定します。
  - リクエストがディレクトリの場合、回答するデフォルトファイルを設定します。
  - 特定のファイル拡張子（例えば.php）に基づいたCGIを実行する。
  - アップロードされたファイルを受け入れることができるルートにし、それらを保存する場所を設定します。
    - CGIってなんだろう？
    - CGIを直接呼び出さないので、PATH_INFOにフルパスを指定します。
    - また、CGIはボディーの終わりとしてEOFを期待します。
    - CGIの出力も同様です。CGIからcontent_lengthが返されない場合、EOFが返されるデータの終わりを意味します。
    - プログラムは、要求されたファイルを第一引数としてCGIを呼び出す必要があります。
    - CGIは、相対パスでアクセスできるよう、正しいディレクトリで実行する必要があります。
    - サーバーは、1つのCGI（php-CGI、Pythonなど）で動作する必要があります。
評価中にすべての機能が動作することをテストし実証するために、いくつかの設定ファイルやデフォルトの基本ファイルを提供する必要があります。
ある動作について疑問がある場合、あなたのプログラムの動作とNGINXの動作を比較する必要があります。
例えば、server_nameがどのように動作するのかを確認します。
私たちは小さなテスターを共有しました。ブラウザやテストが正常に動作するのであれば、それをパスすることは必須ではありませんが、いくつかのバグを見つけるのに役立ちます。
重要なのは弾力性です。あなたのサーバーは決して死なないはずです。
一つのプログラムだけでテストするのはやめましょう。PythonやGolangなど、より便利な言語でテストを書きましょう。必要であれば、CやC++でも。